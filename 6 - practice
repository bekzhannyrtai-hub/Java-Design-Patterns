import java.util.Scanner;

interface ICostCalculationStrategy {
    double calculateCost(double distance, int passengers, boolean isBusiness, boolean hasDiscount);
}

class AirplaneStrategy implements ICostCalculationStrategy {
    public double calculateCost(double distance, int passengers, boolean isBusiness, boolean hasDiscount) {
        double base = distance * 0.5 * passengers;
        if (isBusiness) base *= 1.5;
        if (hasDiscount) base *= 0.9;
        return base + 50;
    }
}

class TrainStrategy implements ICostCalculationStrategy {
    public double calculateCost(double distance, int passengers, boolean isBusiness, boolean hasDiscount) {
        double base = distance * 0.2 * passengers;
        if (isBusiness) base *= 1.3;
        if (hasDiscount) base *= 0.85;
        return base + 20;
    }
}

class BusStrategy implements ICostCalculationStrategy {
    public double calculateCost(double distance, int passengers, boolean isBusiness, boolean hasDiscount) {
        double base = distance * 0.1 * passengers;
        if (isBusiness) base *= 1.2;
        if (hasDiscount) base *= 0.8;
        return base + 10;
    }
}

class TravelBookingContext {
    private ICostCalculationStrategy strategy;

    public void setStrategy(ICostCalculationStrategy strategy) {
        this.strategy = strategy;
    }

    public double calculate(double distance, int passengers, boolean isBusiness, boolean hasDiscount) {
        if (strategy == null) throw new IllegalStateException("Стратегия не выбрана");
        return strategy.calculateCost(distance, passengers, isBusiness, hasDiscount);
    }
}

public class TravelBooking {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        TravelBookingContext context = new TravelBookingContext();

        System.out.println("Выберите транспорт: 1 - Самолет, 2 - Поезд, 3 - Автобус");
        int choice = sc.nextInt();

        switch (choice) {
            case 1 -> context.setStrategy(new AirplaneStrategy());
            case 2 -> context.setStrategy(new TrainStrategy());
            case 3 -> context.setStrategy(new BusStrategy());
            default -> {
                System.out.println("Неверный выбор");
                return;
            }
        }

        System.out.print("Введите расстояние (км): ");
        double distance = sc.nextDouble();

        System.out.print("Введите количество пассажиров: ");
        int passengers = sc.nextInt();

        System.out.print("Бизнес класс? (true/false): ");
        boolean isBusiness = sc.nextBoolean();

        System.out.print("Есть скидка (дети/пенсионеры)? (true/false): ");
        boolean hasDiscount = sc.nextBoolean();

        double total = context.calculate(distance, passengers, isBusiness, hasDiscount);
        System.out.printf("Стоимость поездки: %.2f₸\n", total);
    }
}

import java.util.*;

interface IObserver {
    void update(String stockName, double price);
}

interface ISubject {
    void registerObserver(String stockName, IObserver observer);
    void removeObserver(String stockName, IObserver observer);
    void notifyObservers(String stockName, double price);
}

class StockExchange implements ISubject {
    private final Map<String, List<IObserver>> observers = new HashMap<>();
    private final Map<String, Double> stockPrices = new HashMap<>();

    public void registerObserver(String stockName, IObserver observer) {
        observers.computeIfAbsent(stockName, k -> new ArrayList<>()).add(observer);
    }

    public void removeObserver(String stockName, IObserver observer) {
        List<IObserver> list = observers.get(stockName);
        if (list != null) list.remove(observer);
    }

    public void notifyObservers(String stockName, double price) {
        List<IObserver> list = observers.get(stockName);
        if (list != null) {
            for (IObserver observer : list) observer.update(stockName, price);
        }
    }

    public void setStockPrice(String stockName, double newPrice) {
        stockPrices.put(stockName, newPrice);
        System.out.println("Цена акции " + stockName + " изменилась: " + newPrice);
        notifyObservers(stockName, newPrice);
    }
}

class Trader implements IObserver {
    private final String name;

    public Trader(String name) {
        this.name = name;
    }

    public void update(String stockName, double price) {
        System.out.println(name + " получил уведомление: " + stockName + " теперь стоит " + price);
    }
}

class AutoTraderBot implements IObserver {
    private final double threshold;

    public AutoTraderBot(double threshold) {
        this.threshold = threshold;
    }

    public void update(String stockName, double price) {
        if (price > threshold)
            System.out.println("Бот продает " + stockName + " по цене " + price);
        else
            System.out.println("Бот покупает " + stockName + " по цене " + price);
    }
}

public class StockMarketSimulation {
    public static void main(String[] args) {
        StockExchange exchange = new StockExchange();

        Trader t1 = new Trader("Али");
        Trader t2 = new Trader("Меруерт");
        AutoTraderBot bot = new AutoTraderBot(150);

        exchange.registerObserver("AAPL", t1);
        exchange.registerObserver("AAPL", bot);
        exchange.registerObserver("TSLA", t2);

        exchange.setStockPrice("AAPL", 145);
        exchange.setStockPrice("TSLA", 250);
        exchange.setStockPrice("AAPL", 170);
    }
}

